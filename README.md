# Offline DX Bundler

> [!NOTE] Currently I suspect this crate is only useful for my specific use case in my larger project. If you could potentially find use for it, let me know!

`offline_dx_bundler` contains build-time utilities for fully offline HTML export. The crate was designed for Dioxus WASM sites, but it's likely possible to adapt it for other frameworks as well.

## Highlights

- Generates an offline manifest describing every site page and asset reference in authored content.
- Produces Rust source that mirrors the runtime helpers so offline builds behave exactly the same as the live application.
- Provides utilities for patching the generated `dx serve` output so that it can be opened directly from disk with no HTTP server.

## Getting Started

Add the crate to your build tooling workspace and create an [`OfflineBuildContext`](https://docs.rs/offline_dx_bundler/latest/offline_dx_bundler/struct.OfflineBuildContext.html) with the layout and paths that describe your project:

```rust,no_run
use offline_dx_bundler::{OfflineBuildContext, OfflineBuilder, OfflineProjectLayout};
use offline_dx_bundler::selection::CollectionInclusion;
use std::path::{Path, PathBuf};

struct IncludeAll;
impl CollectionInclusion for IncludeAll {
    fn is_included(&self, _collection_id: &str) -> bool {
        true
    }
}

fn main() -> anyhow::Result<()> {
    let layout = OfflineProjectLayout {
        entry_assets_dir: "assets".into(),
        entry_markdown_file: "index.md".into(),
        collection_metadata_file: "collection.json".into(),
        excluded_dir_name: "prod".into(),
        excluded_path_fragment: "/prod/".into(),
        collection_asset_literal_prefix: "/content/programs".into(),
        offline_site_root: "site".into(),
        collections_dir_name: "programs".into(),
        offline_bundle_root: "target/offline-html".into(),
        index_html_file: "index.html".into(),
        target_dir: "target".into(),
        offline_manifest_json: "offline_manifest.json".into(),
    };

    let manifest_dir = Path::new("./rs");
    let collections_dir = Path::new("./content/programs");
    let context = OfflineBuildContext::new(
        layout,
        manifest_dir,
        collections_dir,
        collections_dir,
        PathBuf::from("./target/offline-assets"),
    );

    let builder = OfflineBuilder::new(context);
    let selection = IncludeAll;

    let artifacts = builder.build(&selection)?;
    println!("Offline manifest JSON: {}", artifacts.offline_manifest_json);
    Ok(())
}
```

The resulting [`OfflineArtifacts`](https://docs.rs/offline_dx_bundler/latest/offline_dx_bundler/struct.OfflineArtifacts.html) structure contains ready-to-write strings for the generated Rust modules and the offline manifest JSON file.

### Runtime configuration

Offline projects describe their layout through the nearest `collection.json`. A root-level
document can provide a `config` object with camelCase fields that override the built-in
defaults:

```json
{
  "config": {
    "collectionsDir": "../content/programs",
    "collectionsLocalPath": "collections.local.json",
    "entryAssetsDir": "assets",
    "entryMarkdownFile": "index.md",
    "collectionMetadataFile": "collection.json"
  }
}
```

Child directories inherit these values automatically. When a deeper `collection.json` defines
its own `config`, those overrides apply to that directory and any descendants, allowing local
tweaks without duplicating the full configuration.

#### Filtering collections at build time

If you want to build a smaller offline bundle, drop a `collections.local.json` file alongside
your authored content. The layout mirrors the legacy behaviour but now honours hierarchical
paths â€“ identifiers such as `P0010-snb` apply to that collection and all descendants, while
`P0010-snb/module-a` only affects the nested entry.

```json
{
  "include": ["P0010-snb"],
  "exclude": ["P0040-demo2", "P0020-loading-updating-charts/dev"]
}
```

When the `include` list is present only the listed identifiers (and their children) are
compiled. The `exclude` list always removes matching identifiers, including their descendants,
allowing you to prune individual branches after broad include rules.

## Examples

Run `cargo run --example manifest_summary` from the crate directory to see how `OfflineManifestSummary` can be used to inspect an existing manifest JSON file.

## Offline bundle helpers

The `bundle` module contains helpers for patching the static output generated by `dx build`. They expect the manifest generated by `OfflineBuilder` and will update the HTML, JavaScript and CSS artefacts so that the application can be opened directly from disk without a server.
