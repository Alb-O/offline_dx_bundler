# Offline DX Bundler

> [!NOTE] Currently I suspect this crate is only useful for my specific use case in my larger project. If you could potentially find use for it, let me know!

`offline_dx_bundler` contains build-time utilities for fully offline HTML export. The crate was designed for Dioxus WASM sites, but it's likely possible to adapt it for other frameworks as well.

## Highlights

- Generates an offline manifest describing every site page and asset reference in authored content.
- Produces Rust source that mirrors the runtime helpers so offline builds behave exactly the same as the live application.
- Provides utilities for patching the generated `dx serve` output so that it can be opened directly from disk with no HTTP server.

## Getting Started

Add the crate to your build tooling workspace and create an [`OfflineBuildContext`](https://docs.rs/offline_dx_bundler/latest/offline_dx_bundler/struct.OfflineBuildContext.html) with the layout and paths that describe your project:

```rust,no_run
use offline_dx_bundler::{OfflineBuildContext, OfflineBuilder, OfflineProjectLayout};
use offline_dx_bundler::selection::CollectionInclusion;
use std::path::{Path, PathBuf};

struct IncludeAll;
impl CollectionInclusion for IncludeAll {
    fn is_included(&self, _collection_id: &str) -> bool {
        true
    }
}

fn main() -> anyhow::Result<()> {
    let layout = OfflineProjectLayout {
        entry_assets_dir: "assets".into(),
        entry_markdown_file: "index.md".into(),
        collection_metadata_file: "collection.json".into(),
        excluded_dir_name: "prod".into(),
        excluded_path_fragment: "/prod/".into(),
        collection_asset_literal_prefix: "/content/programs".into(),
        offline_site_root: "site".into(),
        collections_dir_name: "programs".into(),
        offline_bundle_root: "target/offline-html".into(),
        index_html_file: "index.html".into(),
        target_dir: "target".into(),
        offline_manifest_json: "offline_manifest.json".into(),
    };

    let manifest_dir = Path::new("./rs");
    let collections_dir = Path::new("./content/programs");
    let context = OfflineBuildContext::new(
        layout,
        manifest_dir,
        collections_dir,
        collections_dir,
        PathBuf::from("./target/offline-assets"),
    );

    let builder = OfflineBuilder::new(context);
    let selection = IncludeAll;

    let artifacts = builder.build(&selection)?;
    println!("Offline manifest JSON: {}", artifacts.offline_manifest_json);
    Ok(())
}
```

The resulting [`OfflineArtifacts`](https://docs.rs/offline_dx_bundler/latest/offline_dx_bundler/struct.OfflineArtifacts.html) structure contains ready-to-write strings for the generated Rust modules and the offline manifest JSON file.

### Runtime configuration

To avoid hard-coding every path, you can drop an `offline.config.json` file next to your Cargo manifest. Any fields you omit fall back to the defaults shown below:

```json
{
  "collections_dir": "../content/programs",
  "collections_local_path": "collections.local.json",
  "entry_assets_dir": "assets",
  "entry_markdown_file": "index.md",
  "collection_metadata_file": "collection.json"
}
```

The build helper automatically loads this file and converts it into the layout used by the bundler.

## Examples

Run `cargo run --example manifest_summary` from the crate directory to see how `OfflineManifestSummary` can be used to inspect an existing manifest JSON file.

## Offline bundle helpers

The `bundle` module contains helpers for patching the static output generated by `dx build`. They expect the manifest generated by `OfflineBuilder` and will update the HTML, JavaScript and CSS artefacts so that the application can be opened directly from disk without a server.
