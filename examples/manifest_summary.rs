use offline_dx_bundler::models::{OfflineManifestSummary, OfflineModuleSummary};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Example manifest containing two programs with a single module each. In a real
    // project this JSON would be generated by `OfflineBuilder` and written to
    // `target/offline_manifest.json`.
    let manifest_json = r#"
    {
        "site_root": "site",
        "hero_assets": ["programs/deckhand/images/hero.jpg"],
        "modules": [
            {
                "program_id": "deckhand",
                "module_id": "introduction",
                "asset_paths": ["programs/deckhand/assets/images/chart.png"]
            },
            {
                "program_id": "watchkeeping",
                "module_id": "safety",
                "asset_paths": []
            }
        ]
    }
    "#;

    let summary: OfflineManifestSummary = serde_json::from_str(manifest_json)?;

    println!("Offline site root: {}", summary.site_root);
    println!("Hero assets: {}", summary.hero_assets.join(", "));

    for OfflineModuleSummary {
        program_id,
        module_id,
        asset_paths,
    } in summary.modules
    {
        println!("{program_id}/{module_id} ({} assets)", asset_paths.len());
    }

    Ok(())
}
