use offline_dx_bundler::models::{OfflineEntrySummary, OfflineManifestSummary};

fn main() -> Result<(), Box<dyn std::error::Error>> {
  // Example manifest containing two programs with a single module each. In a real
  // project this JSON would be generated by `OfflineBuilder` and written to
  // `target/offline_manifest.json`.
  let manifest_json = r#"
    {
        "site_root": "site",
        "hero_assets": ["programs/deckhand/images/hero.jpg"],
        "modules": [
            {
                "entry_id": "deckhand",
                "collection_id": "introduction",
                "asset_paths": ["programs/deckhand/assets/images/chart.png"]
            },
            {
                "entry_id": "watchkeeping",
                "collection_id": "safety",
                "asset_paths": []
            }
        ]
    }
    "#;

  let summary: OfflineManifestSummary = serde_json::from_str(manifest_json)?;

  println!("Offline site root: {}", summary.site_root);
  println!("Hero assets: {}", summary.hero_assets.join(", "));

  for OfflineEntrySummary {
    entry_id,
    collection_id,
    asset_paths,
  } in summary.entries
  {
    println!("{entry_id}/{collection_id} ({} assets)", asset_paths.len());
  }

  Ok(())
}
